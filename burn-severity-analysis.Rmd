---
title: "Burn severity calibration"
output: html_document
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "figs-knitr/",
  cache.path = "cache/",
  cache = TRUE,
  autodep = TRUE
)
```

We'll start by loading some packages and reading in a number of functions that
are included in `zoib-functions.R`:

```{r functions, cache=FALSE, warning=FALSE, message=FALSE, results='hide'}
source("zoib-functions.R")
library("tidyverse")
library("rstan")
library("doParallel")
library("ggsidekick") # devtools::install_github("seananderson/ggsidekick")
rstan_options(auto_write = TRUE)
# options(mc.cores = parallel::detectCores())
options(mc.cores = 1)
sm <- stan_model("zoib1re.stan")
registerDoParallel(cores = round(parallel::detectCores() / 2))
file <- file.path("data", "RockiesBurnSev_clean_20180216.csv")
```

# Question 1: best simple bivariate models?

Fit all satellite predictors to all field measure responses:

```{r fit-all-q1, cache=TRUE}
x_vars <- c(
  "dNBR",
  "dNBR_BL",
  "RdNBR",
  "RdNBR_BL",
  "RBR",
  "RBR_BL"
)
y_vars <- c(
  "Firemort.BA.p",
  "Firemort.trees.p",
  "CHARHT_percMax",
  "BOLESCORCH",
  "CHARCOV"
)
vars <- expand.grid(x = x_vars, y = y_vars, stringsAsFactors = FALSE)

out_q1 <- plyr::mlply(.data = vars, function(x, y) { # or map2() without parallel
  d <- get_dat(!!quo_name(y), !!quo_name(x),
    file = file, max_predictor = 2500
  )
  m <- fit_model(d,
    model = sm, predictors = "xscaled", iter = 1000L,
    chains = 4L
  )
  list(m = m, d = d, x = x, y = y)
}, .parallel = TRUE)
```

Basic plots for supplement:

```{r}
var_names <- read.csv("data/VariableNames.csv", stringsAsFactors = FALSE, strip.white = TRUE) %>%
  rename(y = old.names)
response_order <- c(
  "Basal area killed by fire",
  "Trees killed by fire",
  "Bole scorch",
  "Char height",
  "Charred surface cover"
)
```

Get AUC values:

```{r aucs_q1, warning=FALSE, cache=TRUE, dependson='fit-all-q1'}
get_loo <- function(x) {
  log_lik <- loo::extract_log_lik(x, merge_chains = FALSE)
  rel_eff <- loo::relative_eff(exp(log_lik), cores = 1L)
  out <- loo::loo.array(log_lik,
    r_eff = rel_eff,
    cores = 1L,
    save_psis = FALSE
  )
  out$estimate["looic", "Estimate"]
}

thresholds <- seq(0.05, 0.95, length.out = 5)

aucs_q1 <- plyr::ldply(out_q1, function(x) {
  predictions <- make_predictions_dat(model = x$m$model, f = x$m$f, d = x$d)
  aucs_i <- make_roc(
    d = x$d, predictions = predictions, return_plot = FALSE,
    thresh = thresholds
  )
  looic <- tryCatch({
    get_loo(x$m$model)
  }, error = function(e) NA)
  b <- broom::tidyMCMC(x$m$model, rhat = TRUE, ess = TRUE)
  data.frame(
    x = x$x, y = x$y,
    auc = aucs_i,
    thresh = thresholds,
    auc_mean = mean(aucs_i), auc_lwr = min(aucs_i), auc_upr = max(aucs_i),
    looic = looic, ess = min(b$ess), rhat = max(b$rhat), stringsAsFactors = FALSE
  )
}, .parallel = TRUE)
```

Plot comparisons:

```{r}
aucs_q1_summ <- select(aucs_q1, -auc, -thresh) %>% unique()
g <- ggplot(aucs_q1_summ, aes(y, x)) +
  viridis::scale_fill_viridis() +
  xlab("") + ylab("") + theme_sleek() +
  coord_cartesian(expand = FALSE)

g + geom_tile(aes(fill = auc_mean))
g + geom_tile(aes(fill = auc_lwr))
g + geom_tile(aes(fill = auc_upr))

aucs_q1_summ %>%
  group_by(y) %>%
  arrange(-auc_mean) %>%
  ungroup() %>%
  ggplot(aes(x, auc_mean, ymin = auc_lwr, ymax = auc_upr, colour = auc_mean)) +
  geom_pointrange() +
  facet_wrap(~y, scales = "free_x") +
  viridis::scale_colour_viridis() +
  xlab("") + ylab("AUC") + theme_sleek() +
  coord_cartesian(expand = FALSE) +
  coord_flip()
```

Ranked within field measurement?

```{r}
aucs_q1_summ %>%
  group_by(y) %>%
  arrange(-auc_mean) %>%
  mutate(rank = seq_len(n())) %>%
  group_by(x) %>%
  mutate(mean_rank = mean(rank)) %>%
  left_join(var_names) %>%
  ungroup() %>%
  mutate(x = gsub("_BL", "-BL", x)) %>%
  ggplot(aes(
    factor(new.names, levels = rev(response_order)),
    forcats::fct_reorder(x, mean_rank)
  )) +
  viridis::scale_fill_viridis(direction = -1) +
  geom_tile(aes(fill = rank)) +
  xlab("") + ylab("") +
  theme_sleek() +
  labs(fill = "Mean\nAUC\nrank") +
  coord_flip(expand = FALSE)
ggsave("figs/mean-auc-ranked.pdf", width = 6.5, height = 3.7)
```

E.g. ROC:

```{r}
x <- out_q1[[20]]
a <- make_predictions_dat(x$m$model, f = x$m$f, d = x$d)
make_roc(x$d, a, thresh = thresholds) +
  ggtitle(paste(var_names$new.names[var_names$y == x$y], "/", x$x)) +
  labs(colour = "Threshold") +
  xlab("False positive rate") +
  ylab("True positive rate") +
  coord_equal() +
  coord_cartesian(expand = FALSE) +
  geom_abline(intercept = 0, slope = 1, lty = 2, col = "grey50")
ggsave("figs/roc-example.pdf", width = 5.5, height = 5, dpi = 200)
```

## Figure 2:

```{r}
temp_dat <- aucs_q1 %>%
  filter(x %in% c("dNBR_BL", "RBR_BL", "RdNBR_BL")) %>%
  mutate(x = gsub("_BL", "", x)) %>%
  left_join(var_names, by = "y") %>%
  mutate(new.names = factor(new.names, levels = response_order))

lets <- data.frame(
  response = response_order,
  panel =
    paste0("(", letters[seq_along(response_order)], ")"),
  stringsAsFactors = TRUE, new.names = response_order
)

upper_panel <-
  ggplot(temp_dat, aes(thresh, auc, colour = x)) +
  geom_line(lwd = 1) +
  facet_wrap(~new.names,
    scales = "fixed", nrow = 1
  ) +
  scale_color_brewer(palette = "Dark2") +
  # viridis::scale_colour_viridis(discrete = TRUE) +
  ggsidekick::theme_sleek() +
  theme_sleek() +
  labs(colour = "Burn severity index") +
  xlab("Proportion threshold") + ylab("AUC") +
  theme(legend.position = c(0.093, 0.26)) +
  scale_y_continuous(breaks = seq(0.8, 0.95, 0.05)) +
  theme(strip.text = element_text(size = rel(0.87))) +
  coord_cartesian(xlim = c(0, 0.99), expand = 0, ylim = c(0.80, 0.98)) +
  geom_text(
    data = lets, aes(label = panel), x = 0.1, y = 0.968,
    inherit.aes = FALSE, col = "grey30"
  )

dat_q1_pred <-
  plyr::ldply(out_q1, function(x) {
    p <- make_predictions(d = x$d, f = x$m$f, model = x$m$model)
    p$response <- var_names$new.names[var_names$y == x$y]
    p$predictor <- x$x
    p
  }, .parallel = TRUE)

dat_q1_raw <-
  plyr::ldply(out_q1, function(x) {
    x$d$response <- var_names$new.names[var_names$y == x$y]
    x$d$predictor <- x$x
    x$d
  }, .parallel = TRUE)

dat_q1_pred$response <- factor(dat_q1_pred$response, levels = response_order)
dat_q1_pred$new.names <- factor(dat_q1_pred$response, levels = response_order)
dat_q1_raw$response <- factor(dat_q1_raw$response, levels = response_order)
dat_q1_raw$new.names <- factor(dat_q1_raw$response, levels = response_order)

lets <- data.frame(
  new.names = response_order,
  panel =
    paste0("(", letters[5 + seq_along(response_order)], ")"),
  stringsAsFactors = TRUE
)

lets$new.names <- factor(lets$new.names, levels = response_order)

lower_panel <- ggplot(
  filter(dat_q1_pred, predictor == "RdNBR_BL"),
  aes(x, est, ymin = lwr, ymax = upr)
) +
  geom_point(
    data = filter(dat_q1_raw, predictor == "RdNBR_BL"),
    aes(x, y, group = group), colour = "grey30",
    inherit.aes = FALSE, alpha = 0.2, size = 0.7
  ) +
  geom_line(aes(y = est_re, group = as.factor(group)),
    col = "grey35", lty = 1, lwd = 0.4, alpha = 0.7
  ) +
  geom_line(
    lwd = 1.5,
    colour = RColorBrewer::brewer.pal(3, "Dark2")[[3]]
  ) +
  geom_ribbon(
    alpha = 0.3,
    fill = RColorBrewer::brewer.pal(3, "Dark2")[[3]]
  ) +
  ylim(0, 1) +
  ggsidekick::theme_sleek() +
  ylab("Proportion") +
  xlab("Predictor value") +
  labs(colour = "Fire location") +
  facet_wrap(~new.names, scales = "fixed", nrow = 1) +
  # facet_wrap(~response, nrow = 1) +
  coord_cartesian(expand = FALSE, ylim = c(-0.03, 1.03)) +
  theme(strip.text = element_text(size = rel(0.87))) +
  geom_text(
    data = lets, aes(label = panel), x = -100, y = 0.96,
    inherit.aes = FALSE, col = "grey30"
  )

cowplot::plot_grid(upper_panel, lower_panel, nrow = 2)
ggsave("figs/fig2.pdf", width = 8.2, height = 4.5, dpi = 220)
```

Fig S1:

```{r}
dat_q1_pred2 <- mutate(dat_q1_pred, response = gsub("Basal area killed by fire", "Basal area\\\nkilled by fire", response))
dat_q1_raw2 <- mutate(dat_q1_raw, response = gsub("Basal area killed by fire", "Basal area\\\nkilled by fire", response))

dat_q1_pred2 <- mutate(dat_q1_pred2, response = gsub("Charred surface cover", "Charred\\\nsurface cover", response))
dat_q1_raw2 <- mutate(dat_q1_raw2, response = gsub("Charred surface cover", "Charred\\\nsurface cover", response))

response_order2 <- gsub(
  "Basal area killed by fire",
  "Basal area\\\nkilled by fire", response_order
)
response_order2 <- gsub(
  "Charred surface cover", "Charred\\\nsurface cover",
  response_order2
)

ggplot(
  filter(dat_q1_pred2),
  aes(x, est, ymin = lwr, ymax = upr)
) +
  geom_point(
    data = filter(dat_q1_raw2),
    aes(x, y, group = group), colour = "grey30",
    inherit.aes = FALSE, alpha = 0.15, size = 0.7
  ) +
  geom_line(aes(y = est_re, group = as.factor(group)),
    col = "grey35", lty = 1, lwd = 0.4, alpha = 0.7
  ) +
  geom_line(lwd = 1.5, colour = "red") +
  geom_ribbon(alpha = 0.2, fill = "red") +
  ylim(0, 1) +
  ggsidekick::theme_sleek() +
  ylab("Proportion") +
  xlab("Predictor value") +
  labs(colour = "Fire location") +
  facet_grid(factor(response, levels = response_order2) ~ predictor,
    scales = "free_x"
  )

ggsave("figs/figS1.pdf", width = 9.5, height = 6, dpi = 200)
```

# Question 2: can we improve with easily available GIS data?

```{r fit-all-q2, cache=TRUE}
x_vars <- c(
  "RdNBR_BL",
  "RdNBR_BL",
  "RdNBR_BL",
  "RdNBR_BL",
  "RdNBR_BL"
)
extra_x_vars <- paste("xscaled", c("lat", "heatload", "slope", "prenbr"), sep = "*")
y_vars <- c(
  "BOLESCORCH",
  "CHARCOV",
  "CHARHT_percMax",
  "Firemort.BA.p",
  "Firemort.trees.p"
)
vars <- data.frame(x = x_vars, y = y_vars, stringsAsFactors = FALSE)

out_q2 <- plyr::mlply(.data = vars, function(x, y) { # or map2() without parallel
  d <- get_dat(!!quo_name(y), !!quo_name(x),
    file = file,
    max_predictor = 2500
  )
  d <- d[!is.na(d$prenbr), , drop = FALSE]
  m <- fit_model(d,
    model = sm,
    predictors = c("xscaled", extra_x_vars),
    iter = 1000L, chains = 4L, cores = 1
  )
  list(m = m, d = d, x = x, y = y)
}, .parallel = TRUE)
```

```{r, fig.height=9, fig.width=10}
out_q2_plot <- out_q2
for (i in seq_along(out_q2_plot)) {
  out_q2_plot[[i]]$y <- var_names$new.names[var_names$y == out_q2_plot[[i]]$y]
}

newnames_df <- data.frame(
  name = c(
    " RdNBR_BL", " RdNBR_BL:heatload", " RdNBR_BL:lat",
    " RdNBR_BL:prenbr",
    " RdNBR_BL:slope", "heatload", "lat", "prenbr", "slope"
  ),
  new.names = c(
    " RdNBR", " RdNBR x heat load", " RdNBR x latitude",
    " RdNBR x pre-fire NBR",
    " RdNBR x slope", "Heat load index", "Latitude", "Pre-fire NBR", "Slope"
  ),
  stringsAsFactors = FALSE
)

p_q2 <- lapply(out_q2_plot, function(x)
  plot_zoib_coefs(x, oib = FALSE, newnames_df = newnames_df, return_df = TRUE))
p_q2 <- bind_rows(p_q2)
pal <- RColorBrewer::brewer.pal(3, "Set2")
x_name <- " RdNBR"
p_q2 <- mutate(p_q2, xvar = fct_relevel(name, x_name, after = Inf))
p_q2 <- mutate(p_q2, response = factor(response, levels = response_order))

gg <- ggplot(p_q2, aes(
  y = estimate, x = xvar,
  colour = model_full, shape = interaction
)) +
  geom_hline(yintercept = 0, lty = 2, col = "grey55") +
  geom_linerange(aes(ymin = conf.low.25, ymax = conf.high.75),
    position = position_dodge(width = 0.4), size = 0.85
  ) +
  geom_linerange(aes(ymin = conf.low, ymax = conf.high),
    position = position_dodge(width = 0.4), size = 0.35
  ) +
  geom_point(position = position_dodge(width = 0.4), size = 1.8) +
  xlab("") +
  facet_wrap(~response) +
  ggsidekick::theme_sleek() +
  coord_flip() +
  scale_color_manual(values = pal, guide = guide_legend(reverse = TRUE)) +
  scale_shape_manual(values = c(19, 21)) +
  labs(colour = "Model", shape = "Interaction", y = "Coefficient value") +
  guides(shape = FALSE) +
  theme(legend.position = c(0.8, 0.3))

ggsave("figs/q2-coefs-facets.pdf", width = 7.2, height = 5.4)
```

All:

```{r}
cols <- viridis::plasma(3, end = 0.85) %>% rev()
quants <- c(0.05, 0.5, 0.95)

inter_vars <- c("lat", "heatload", "slope", "prenbr")
inter_vars_long <- c("Latitude", "Heat load index", "Slope", "pe-fire NBR")
vars_i <- seq_along(inter_vars)
response_j <- seq_along(out_q2)
q2_inter_plots <- list()
k <- 0
for (j in response_j) {
  for (i in vars_i) {
    k <- k + 1
    q2_inter_plots[[k]] <-
      plot_interaction(out_q2[[j]],
        int_var = inter_vars[i], int_lab = paste0("\n", inter_vars_long[i]),
        xlab = gsub("_BL", "", x_vars[[1]]), col = cols, quant = quants,
        title = var_names$new.names[var_names$y == vars$y[[j]]],
        type = "zoib"
      )
  }
}
```

```{r}
cols <- viridis::plasma(3, end = 0.85) %>% rev()
quants <- c(0.05, 0.5, 0.95)

inter_vars <- c("lat", "heatload", "slope", "prenbr")
inter_vars_long <- c("Latitude", "Heat load index", "Slope", "pe-fire NBR")
vars_i <- seq_along(inter_vars)
response_j <- seq_along(out_q2)
q2_inter_plots <- list()
k <- 0
for (j in response_j) {
  for (i in vars_i) {
    k <- k + 1
    q2_inter_plots[[k]] <-
      plot_interaction(out_q2[[j]],
        int_var = inter_vars[i],
        int_lab = paste0("\n", inter_vars_long[i]),
        xlab = gsub("_BL", "", "RdNBR_BL"), col = cols, quant = quants,
        title = var_names$new.names[var_names$y == vars$y[[j]]],
        type = "zoib", return_data = TRUE
      )
    q2_inter_plots[[k]]$interaction <- inter_vars_long[i]
    q2_inter_plots[[k]]$response <-
      var_names$new.names[var_names$y == vars$y[[j]]]
  }
}
q2_inter_plots_df <- bind_rows(q2_inter_plots)
q2_inter_plots_df$level <- as.factor(q2_inter_plots_df$level)

lets <- expand.grid(
  response = factor(response_order, levels = response_order),
  interaction = factor(inter_vars_long, levels = sort(inter_vars_long))
) %>%
  arrange(interaction, response) %>%
  mutate(panel = paste0("(", letters[seq_len(n())], ")"))

g <- ggplot(q2_inter_plots_df, aes(x, est,
  ymin = lwr, ymax = upr, group = level,
  fill = level
)) +
  geom_line(lwd = 1.2, aes(colour = level)) +
  geom_ribbon(alpha = 0.25) +
  facet_grid(interaction ~ factor(response, levels = response_order)) +
  ggsidekick::theme_sleek() +
  ylab("Proportion") +
  labs(
    colour = "Quantile",
    fill = "Quantile"
  ) +
  scale_colour_manual(values = cols, guide = guide_legend(reverse = TRUE)) +
  scale_fill_manual(values = cols, guide = guide_legend(reverse = TRUE)) +
  scale_y_continuous(breaks = c(seq(0, 0.8, 0.2)), limits = c(0, 1)) +
  coord_cartesian(expand = FALSE) +
  theme(
    legend.justification = c(1, 0), legend.position = c(0.2, 0.8),
    panel.spacing = unit(-0.05, "lines"),
    legend.title = element_text(size = rel(0.8))
  ) +
  xlab("RdNBR") +
  geom_text(
    data = lets, aes(label = panel), x = -100, y = 0.9,
    inherit.aes = FALSE, col = "grey30"
  )

pdf("figs/q2-interaction-ribbons.pdf", width = 9, height = 5.5)
print(g)
dev.off()
```

Get AUC values:

```{r}
aucs_q2 <- plyr::ldply(out_q2, function(x) {
  predictions <- make_predictions_dat(model = x$m$model, f = x$m$f, d = x$d)
  aucs_i <- make_roc(d = x$d, predictions = predictions, return_plot = FALSE, thresh = thresholds)
  looic <- tryCatch({
    get_loo(x$m$model)
  }, error = function(e) NA)
  b <- broom::tidyMCMC(x$m$model, rhat = TRUE, ess = TRUE)
  data.frame(
    x = x$x, y = x$y,
    auc = aucs_i,
    thresh = thresholds,
    auc_mean = mean(aucs_i), auc_lwr = min(aucs_i), auc_upr = max(aucs_i),
    looic = looic, ess = min(b$ess), rhat = max(b$rhat), stringsAsFactors = FALSE
  )
}, .parallel = FALSE)
```

Check LOOIC:

```{r}
semi_join(aucs_q1, select(aucs_q2, x, y)) %>%
  arrange(x, y) %>%
  select(x, y, looic, ess, rhat) %>%
  unique()
aucs_q2 %>%
  arrange(x, y) %>%
  select(x, y, looic, ess, rhat) %>%
  unique()
```

# Q3 How are the "best" models affected by important characteristics of stand structure, that are NOT easily attainable?

Because the quadratic mean diameter predictors are not available for the 0s (not
burned at all) we will have to use a "OIB" one-inflated-beta GLMM. Here I am
including all of the interactions in a single model. Note that each predictor
has been scaled by dividing by 2 SDs and subtracting its mean. This puts them on
approximately the same scale.

```{r q3-fit, cache=TRUE}
sm <- stan_model("zoib1re.stan")
sm_oib <- stan_model("oib1re.stan")

x_vars <- c(
  "RdNBR_BL",
  "RdNBR_BL",
  "RdNBR_BL",
  "RdNBR_BL",
  "RdNBR_BL"
)
y_vars <- c(
  "BOLESCORCH",
  "CHARCOV",
  "CHARHT_percMax",
  "Firemort.BA.p",
  "Firemort.trees.p"
)
vars <- data.frame(x = x_vars, y = y_vars, stringsAsFactors = FALSE)

x_vars <- tolower(c("xscaled"))
extra_x_vars <- c("qmd_all", "ba_ha", "stems_ha", "redgraygreenstage_ba_p")
x_vars <- paste(x_vars, extra_x_vars, sep = " * ")

out_q3 <- plyr::mlply(.data = vars, function(x, y) { # or map2() without parallel
  d <- get_dat(!!quo_name(y), !!quo_name(x), file = file, max_predictor = 2500)
  dd <- filter(d, !is.na(qmd_all))
  m <- fit_model_oib(dd, sm_oib,
    predictors = x_vars, iter = 1000, chains = 4, cores = 1
  )
  list(m = m, d = dd, x = x, y = y)
}, .parallel = TRUE)
```

Let's plot out the main effect coefficients and the interaction coefficients.
This takes a little bit of data manipulation first. The dots are medians, the
thick lines are 50% credible intervals, and the thin lines are 95% credible
intervals.

```{r plot-interactions, cache=TRUE, fig.height=9, fig.width=10}
out_q3_plot <- out_q3

for (i in seq_along(out_q3_plot)) {
  out_q3_plot[[i]]$y <- var_names$new.names[var_names$y == out_q3_plot[[i]]$y]
}

newnames_df <- data.frame(
  name = c(
    " RdNBR_BL", "qmd_all", "ba_ha", "stems_ha", "redgraygreenstage_ba_p",
    " RdNBR_BL:qmd_all", " RdNBR_BL:ba_ha", " RdNBR_BL:stems_ha",
    " RdNBR_BL:redgraygreenstage_ba_p"
  ),
  new.names = c(
    " RdNBR", "QMD", "Stand basal area", "Stand density", "Pre-fire beetle outbreak severity",
    " RdNBR x QMD", " RdNBR x stand basal area", " RdNBR x stand density",
    " RdNBR x pre-fire beetle outbreak severity"
  ),
  stringsAsFactors = FALSE
)

p_q3 <- lapply(out_q3_plot, function(x)
  plot_zoib_coefs(x, oib = TRUE, newnames_df = newnames_df, return_df = TRUE))
p_q3 <- bind_rows(p_q3)
pal <- RColorBrewer::brewer.pal(3, "Set2")
x_name <- " RdNBR"
p_q3 <- mutate(p_q3, xvar = fct_relevel(name, x_name, after = Inf))
p_q3 <- mutate(p_q3, response = factor(response, levels = response_order))

gg <- ggplot(p_q3, aes(
  y = estimate, x = xvar,
  colour = model_full, shape = interaction
)) +
  geom_hline(yintercept = 0, lty = 2, col = "grey55") +
  geom_linerange(aes(ymin = conf.low.25, ymax = conf.high.75),
    position = position_dodge(width = 0.4), size = 0.85
  ) +
  geom_linerange(aes(ymin = conf.low, ymax = conf.high),
    position = position_dodge(width = 0.4), size = 0.35
  ) +
  geom_point(position = position_dodge(width = 0.4), size = 1.8) +
  xlab("") +
  facet_wrap(~response) +
  ggsidekick::theme_sleek() +
  coord_flip() +
  scale_color_manual(values = pal, guide = guide_legend(reverse = TRUE)) +
  scale_shape_manual(values = c(19, 21)) +
  labs(colour = "Model", shape = "Interaction", y = "Coefficient value") +
  guides(shape = FALSE) +
  theme(legend.position = c(0.8, 0.3))

ggsave("figs/q3-coefs-facets.pdf", width = 7.2, height = 5.4)
```

```{r}
inter_vars <- c("qmd_all", "ba_ha", "stems_ha", "redgraygreenstage_ba_p")
inter_vars_long <- c(
  "QMD", "Stand\nbasal area", "Stand density",
  "Pre-fire beetle\noutbreak severity"
)
vars_i <- seq_along(inter_vars)
response_j <- seq_along(out_q3)
q3_inter_plots <- list()
k <- 0
for (j in response_j) {
  for (i in vars_i) {
    k <- k + 1
    q3_inter_plots[[k]] <-
      plot_interaction(out_q3[[j]],
        int_var = inter_vars[i],
        int_lab = paste0("\n", inter_vars_long[i]),
        xlab = gsub("_BL", "", "RdNBR_BL"), col = cols, quant = quants,
        title = var_names$new.names[var_names$y == vars$y[[j]]],
        type = "oib", return_data = TRUE
      )
    q3_inter_plots[[k]]$interaction <- inter_vars_long[i]
    q3_inter_plots[[k]]$response <- var_names$new.names[var_names$y == vars$y[[j]]]
  }
}
q3_inter_plots_df <- bind_rows(q3_inter_plots)
q3_inter_plots_df$level <- as.factor(q3_inter_plots_df$level)

dd <- get_dat(
  response = "Firemort.BA.p",
  main_predictor = "RdNBR_BL", file = file
)

lets <- expand.grid(
  response = factor(response_order, levels = response_order),
  interaction = factor(inter_vars_long, levels = sort(inter_vars_long))
) %>%
  arrange(interaction, response) %>%
  mutate(panel = paste0("(", letters[seq_len(n())], ")"))

xlim_range <- range(dd$x)
g <- ggplot(q3_inter_plots_df, aes(x, est,
  ymin = lwr, ymax = upr,
  group = level, fill = level
)) +
  geom_line(lwd = 1.2, aes(colour = level)) +
  geom_ribbon(alpha = 0.25) +
  facet_grid(interaction ~ factor(response, levels = response_order)) +
  ggsidekick::theme_sleek() +
  ylab("Proportion") +
  labs(
    colour = "Quantile",
    fill = "Quantile"
  ) +
  scale_colour_manual(values = cols, guide = guide_legend(reverse = TRUE)) +
  scale_fill_manual(values = cols, guide = guide_legend(reverse = TRUE)) +
  scale_y_continuous(breaks = c(seq(0, 0.8, 0.2)), limits = c(0, 1)) +
  coord_cartesian(expand = FALSE) +
  theme(
    legend.justification = c(1, 0), legend.position = c(0.2, 0.8),
    panel.spacing = unit(-0.05, "lines"),
    legend.title = element_text(size = rel(0.8))
  ) +
  xlab("RdNBR") +
  xlim(xlim_range) +
  geom_text(
    data = lets, aes(label = panel), x = -100, y = 0.9,
    inherit.aes = FALSE, col = "grey30"
  )

pdf("figs/q3-interaction-ribbons.pdf", width = 8, height = 5.5)
print(g)
dev.off()
```

# Compare AUC across Q1, Q2, Q3

```{r}
aucs_q1$Q <- "Q1"
aucs_q2$Q <- "Q2"
aucs <- bind_rows(aucs_q1, aucs_q2) %>%
  filter(x == "RdNBR_BL")

lets <- data.frame(
  new.names = response_order,
  panel =
    paste0("(", letters[seq_along(response_order)], ")"),
  stringsAsFactors = FALSE
)

aucs %>%
  mutate(x = gsub("_BL", "", x)) %>%
  left_join(var_names, by = "y") %>%
  ggplot(aes(thresh, auc, colour = Q)) +
  geom_line(lwd = 1.0) +
  facet_wrap(~ factor(new.names, levels = response_order),
    scales = "fixed", nrow = 1
  ) +
  scale_color_brewer(palette = "Set1") +
  ggsidekick::theme_sleek() +
  theme_sleek() +
  labs(colour = "Covariates") +
  xlab("Proportion threshold") + ylab("AUC") +
  theme(legend.position = c(0.07, 0.26)) +
  scale_y_continuous(breaks = seq(0.8, 0.95, 0.05)) +
  theme(strip.text = element_text(size = rel(0.87))) +
  coord_cartesian(xlim = c(0, 0.99), ylim = c(0.82, 0.98), expand = 0) +
  geom_text(
    data = lets, aes(label = panel), x = 0.1, y = 0.968,
    inherit.aes = FALSE, col = "grey30"
  )
ggsave("figs/auc-q1-vs-q2.pdf", width = 8.2, height = 2.5, dpi = 200)
```
