---
title: "Burn severity calibration"
output: html_document
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "figs-knitr/",
  cache.path = "cache/",
  cache = TRUE,
  autodep = TRUE
)
```

We'll start by loading some packages and reading in a number of functions that
are included in `zoib-functions.R`:

```{r functions, cache=FALSE, warning=FALSE, message=FALSE, results='hide'}
source("zoib-functions.R")
library("tidyverse")
library("rstan")
library("doParallel")
library("ggsidekick") # devtools::install_github("seananderson/ggsidekick")
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
sm <- stan_model("zoib1re.stan")
registerDoParallel(cores = parallel::detectCores())
file <- file.path("data", "RockiesBurnSev_clean_20180216.csv")
```

# Question 1: best simple bivariate models?

Fit all satellite predictors to all field measure responses:

```{r fit-all-q1, cache=TRUE}
x_vars <- c(
  "dNBR",
  "dNBR_BL",
  "dNBR_Offset",
  "dNBR_Offset_BL",
  "RdNBR",
  "RdNBR_BL",
  "RBR",
  "RBR_BL"
)
y_vars <- c(
  "Firemort.BA.p",
  "Firemort.trees.p",
  "CHARHT_percMax",
  "BOLESCORCH",
  "CHARCOV")
vars <- expand.grid(x = x_vars, y = y_vars, stringsAsFactors = FALSE)

out_q1 <- plyr::mlply(.data = vars, function(x, y) { # or map2() without parallel
  d <- get_dat(!!quo_name(y), !!quo_name(x),
    file = file, max_predictor = 2500)
  m <- fit_model(d, model = sm, predictors = "xscaled", iter = 1000L, chains = 1L)
  list(m = m, d = d, x = x, y = y)
}, .parallel = TRUE)
```

Get AUC values:

```{r aucs_q1, warning=FALSE, cache=TRUE, dependson='fit-all-q1'}
get_loo <- function(x) {
  log_lik <- loo::extract_log_lik(x, merge_chains = FALSE)
  rel_eff <- loo::relative_eff(exp(log_lik), cores = 1L)
  out <- loo::loo.array(log_lik,
    r_eff = rel_eff,
    cores = 1L,
    save_psis = FALSE)
  out$estimate["looic", "Estimate"]
}

thresholds <- seq(0.2, 0.8, length.out = 5)

aucs_q1 <- plyr::ldply(out_q1, function(x) {
  predictions <- make_predictions_dat(model = x$m$model, f = x$m$f, d = x$d)
  aucs_i <- make_roc(d = x$d, predictions = predictions, return_plot = FALSE, thresh = thresholds)
  looic <- tryCatch({get_loo(x$m$model)}, error = function(e) NA )  
  b <- broom::tidyMCMC(x$m$model, rhat = TRUE, ess = TRUE)
  data.frame(x = x$x, y = x$y,
    auc = aucs_i,
    thresh = thresholds,
    auc_mean = mean(aucs_i), auc_lwr = min(aucs_i), auc_upr = max(aucs_i),
    looic = looic, ess = min(b$ess), rhat = max(b$rhat), stringsAsFactors = FALSE)
}, .parallel = TRUE)
```

Plot comparisons:

```{r}
var_names <- read.csv("data/VariableNames.csv", stringsAsFactors = FALSE, strip.white = TRUE) %>% 
  rename(y = old.names)
aucs_q1_summ <- select(aucs_q1, -auc, -thresh) %>% unique()
g <- ggplot(aucs_q1_summ, aes(y, x)) +
  viridis::scale_fill_viridis() +
  xlab("") + ylab("") + theme_sleek() +
  coord_cartesian(expand = FALSE)

g + geom_tile(aes(fill = auc_mean))
g + geom_tile(aes(fill = auc_lwr))
g + geom_tile(aes(fill = auc_upr))

aucs_q1_summ %>% group_by(y) %>%
  arrange(-auc_mean) %>% 
  ungroup() %>% 
  ggplot(aes(x, auc_mean, ymin = auc_lwr, ymax = auc_upr, colour = auc_mean)) +
  geom_pointrange() +
  facet_wrap(~y, scales = "free_x") +
  viridis::scale_colour_viridis() +
  xlab("") + ylab("AUC") + theme_sleek() +
  coord_cartesian(expand = FALSE) + 
  coord_flip()
```

Ranked within field measurement?

```{r}
aucs_q1_summ %>% group_by(y) %>%
  arrange(-auc_mean) %>%
  mutate(rank = seq_len(n())) %>%
  group_by(x) %>%
  mutate(mean_rank = mean(rank)) %>%
  ggplot(aes(y, forcats::fct_reorder(x, -mean_rank))) +
  viridis::scale_fill_viridis(direction = -1) +
  geom_tile(aes(fill = rank)) +
  xlab("") + ylab("") +
  theme_sleek() +
  coord_cartesian(expand = FALSE)
```

## Figure 2:

```{r}
aucs_q1 %>% filter(x %in% c("dNBR_BL", "RBR_BL", "RdNBR_BL")) %>%
  mutate(x = gsub("_BL", "", x)) %>% 
  left_join(var_names, by = "y") %>% 
  ggplot(aes(thresh, auc, colour = x)) +
  geom_line() + 
  facet_wrap(~new.names, scales = "fixed", nrow = 1) +
  scale_color_brewer(palette = "Dark2") +
  # viridis::scale_colour_viridis(discrete = TRUE) +
  ggsidekick::theme_sleek() +
  theme_sleek() +
  labs(colour = "Burn severity index") +
  xlab("Proportion burned threshold") + ylab("AUC") + 
  theme(legend.position = c(0.905, 0.23)) +
  scale_y_continuous(breaks = seq(0.8, 0.95, 0.025)) +
  theme(strip.text = element_text(size = rel(0.87)))
ggsave("figs/fig2.pdf", width = 8.2, height = 2.5)
```

Cross-val. Go-go-gadget 8 cores:

```{r q1-cross-val, cache=TRUE}
dir.create("data-generated", showWarnings = FALSE)
d <- get_dat(Firemort.BA.p, RdNBR, file = file)
fires <- unique(d$group) %>% as.character()

if (!file.exists("data-generated/q1-out-cv.rds")) {
  out_cv <- plyr::mlply(.data = vars, function(x, y) { # or map2() without parallel
    d <- get_dat(!!quo_name(y), !!quo_name(x),
      file = file,
      max_predictor = 2500)
    m <- map(fires, function(x) {
      fit_model(d = d[d$group != x, , drop = FALSE], model = sm,
        predictors = "xscaled", iter = 500L, chains = 1L, log_lik = FALSE)
    })
    p <- map2_df(m, fires, function(x, y) {
      dd <- d[d$group == y, , drop = FALSE]
      dd$prediction <- make_predictions_dat(d = dd, f = x$f, model = x$model)
      dd
    })
    rhat <- map_dbl(m, function(mm) max(summary(mm$model)$summary[,"Rhat"]))
    ess <- map_dbl(m, function(mm) max(summary(mm$model)$summary[,"n_eff"]))
    list(p = p, d = d, x = x, y = y, rhat = rhat, ess = ess, fires = fires)
  }, .parallel = TRUE)
  saveRDS(out_cv, file = "data-generated/q1-out-cv.rds")
} else {
  out_cv <- readRDS("data-generated/q1-out-cv.rds")
}
```

Get AUC values:

```{r, warning=FALSE}
aucs_cv <- map_df(out_cv, function(x) {
  aucs_i <- make_roc(d = x$p, predictions = x$p$prediction, return_plot = FALSE, thresh = thresholds)
  data.frame(x = x$x, y = x$y, auc = aucs_i, thresh = thresholds,
    auc_mean = mean(aucs_i), auc_lwr = min(aucs_i), auc_upr = max(aucs_i),
    stringsAsFactors = FALSE)
})
```

Plot comparisons:

```{r}
aucs_cv_summ <- select(aucs_cv, -auc, -thresh) %>% unique()
g <- ggplot(aucs_cv_summ, aes(y, x)) +
  viridis::scale_fill_viridis() +
  xlab("") + ylab("") + theme_sleek() +
  coord_cartesian(expand = FALSE)

g + geom_tile(aes(fill = auc_mean))
g + geom_tile(aes(fill = auc_lwr))
g + geom_tile(aes(fill = auc_upr))
```

Ranked within field measurement and ordered by mean rank:

```{r}
aucs_cv_summ %>% group_by(y) %>%
  arrange(-auc_mean) %>%
  mutate(rank = seq_len(n())) %>%
  group_by(x) %>%
  mutate(mean_rank = mean(rank)) %>%
  ggplot(aes(y, forcats::fct_reorder(x, -mean_rank))) +
  viridis::scale_fill_viridis(direction = -1) +
  geom_tile(aes(fill = rank)) +
  xlab("") + ylab("") +
  theme_sleek() +
  coord_cartesian(expand = FALSE)
```

## Figure 2 with CV:

```{r}
aucs_cv %>% filter(x %in% c("dNBR_BL", "RBR_BL", "RdNBR_BL")) %>%
  mutate(x = gsub("_BL", "", x)) %>% 
  left_join(var_names, by = "y") %>% 
  ggplot(aes(thresh, auc, colour = x)) +
  geom_line() + 
  facet_wrap(~new.names, scales = "fixed", nrow = 1) +
  scale_color_brewer(palette = "Dark2") +
  # viridis::scale_colour_viridis(discrete = TRUE) +
  ggsidekick::theme_sleek() +
  theme_sleek() +
  labs(colour = "Burn severity index") +
  xlab("Proportion burned threshold") + ylab("AUC") + 
  theme(legend.position = c(0.905, 0.23)) +
  scale_y_continuous(breaks = seq(0.8, 0.95, 0.025)) +
  theme(strip.text = element_text(size = rel(0.87)))
ggsave("figs/fig2-cv.pdf", width = 8.2, height = 2.5)
```

# Question 2: can we improve with easily available GIS data?

At this point going to use the best predictors for each response only. Will be including the main effects and the interactions.

```{r fit-all-q2, cache=TRUE}
x_vars <- c(
  "RdNBR_BL",
  "RdNBR_BL",
  "RdNBR_BL",
  "RdNBR_BL",
  "RdNBR_BL"
)
extra_x_vars <- paste("xscaled", c("lat", "heatload", "slope", "prenbr"), sep = "*")
y_vars <- c(
  "BOLESCORCH",
  "CHARCOV",
  "CHARHT_percMax",
  "Firemort.BA.p",
  "Firemort.trees.p")
vars <- data.frame(x = x_vars, y = y_vars, stringsAsFactors = FALSE)

out_q2 <- plyr::mlply(.data = vars, function(x, y) { # or map2() without parallel
  d <- get_dat(!!quo_name(y), !!quo_name(x),
    file = file,
    max_predictor = 2500)
  d <- d[!is.na(d$prenbr), , drop = FALSE] # 1 row TODO
  m <- fit_model(d, model = sm,
    predictors = c("xscaled", extra_x_vars),
    iter = 3000L, chains = 1L)
  list(m = m, d = d, x = x, y = y)
}, .parallel = TRUE)
```

```{r, fig.height=9, fig.width=10}
p_q2 <- lapply(out_q2, function(x) plot_zoib_coefs(x, oib = FALSE))
library(gridExtra)
n <- length(p_q2)
nCol <- floor(sqrt(n))
do.call("grid.arrange", c(p_q2, ncol = nCol))
```

Examples:

```{r}
plot_interaction(out_q2[[1]], int_var = "lat", int_lab = "\nlatitude",
  xlab = vars$x[[1]], col = cols, quant = quants, title = vars$y[[1]], type = "zoib")

plot_interaction(out_q2[[1]], int_var = "slope", int_lab = "\nslope",
  xlab = vars$x[[1]], col = cols, quant = quants, title = vars$y[[1]], type = "zoib")

plot_interaction(out_q2[[2]], int_var = "lat", int_lab = "\nlatitude",
  xlab = vars$x[[2]], col = cols, quant = quants, title = vars$y[[2]], type = "zoib")

plot_interaction(out_q2[[3]], int_var = "prenbr", int_lab = "\npre NBR",
  xlab = vars$x[[3]], col = cols, quant = quants, title = vars$y[[3]], type = "zoib")

plot_interaction(out_q2[[4]], int_var = "lat", int_lab = "\nlatitude",
  xlab = vars$x[[4]], col = cols, quant = quants, title = vars$y[[4]], type = "zoib")

plot_interaction(out_q2[[5]], int_var = "heatload", int_lab = "\nheatload",
  xlab = vars$x[[5]], col = cols, quant = quants, title = vars$y[[5]], type = "zoib")
```

All:

```{r}
cols <- viridis::plasma(3, end = 0.85) %>% rev()
quants <- c(0.05, 0.5, 0.95)

inter_vars <- c("lat", "heatload", "slope", "prenbr")
inter_vars_long <- c("Latitude", "Heat load index", "Slope", "pe-fire NBR")
vars_i <- seq_along(inter_vars)
response_j <- seq_along(out_q2)
q2_inter_plots <- list()
k <- 0
for (j in response_j) {
  for (i in vars_i) {
    k <- k + 1
    q2_inter_plots[[k]] <- 
      plot_interaction(out_q2[[j]], int_var = inter_vars[i], int_lab = paste0("\n", inter_vars_long[i]), 
      xlab = gsub("_BL", "", x_vars[[1]]), col = cols, quant = quants, 
        title = var_names$new.names[var_names$y == vars$y[[j]]], 
        type = "zoib")
  }
}
pdf("figs/q2-interaction-ribbons.pdf", width = 13, height = 10)
do.call("grid.arrange", c(q2_inter_plots, nrow = length(response_j)))
dev.off()
```


Get AUC values:

```{r, warning=FALSE}
aucs_q2 <- plyr::ldply(out_q2, function(x) {
  predictions <- make_predictions_dat(model = x$m$model, f = x$m$f, d = x$d)
  aucs_i <- make_roc(d = x$d, predictions = predictions, return_plot = FALSE)
  looic <- tryCatch({get_loo(x$m$model)}, error = function(e) NA )  
  b <- broom::tidyMCMC(x$m$model, rhat = TRUE, ess = TRUE)
  data.frame(x = x$x, y = x$y,
    auc_mean = mean(aucs_i), auc_lwr = min(aucs_i), auc_upr = max(aucs_i),
    looic = looic, ess = min(b$ess), rhat = max(b$rhat), stringsAsFactors = FALSE)
}, .parallel = TRUE)
```

Check LOOIC:

```{r}
semi_join(aucs_q1, select(aucs_q2, x, y)) %>% arrange(x, y)
aucs_q2 %>% arrange(x, y)
```

A possible type of plot looking at the increase in the range of AUC. Might be better done for a cross validation set. This is currently done on the full data set. Alternatively could do something with LOOIC (which is analogous to AIC).

```{r}
aucs_q1$q <- "q1"
aucs_q2$q <- "q2"
temp <- bind_rows(semi_join(aucs_q1, select(aucs_q2, x, y)), aucs_q2) %>% 
  filter(rhat < 1.2, ess > 15) %>% # TODO increase!
  mutate(y = as.factor(y)) %>% 
  mutate(y_val = ifelse(q == "q1", as.numeric(y) - 0.1, as.numeric(y) + 0.1))
labs <- select(temp, y) %>% mutate(y_val = as.numeric(y)) %>% unique() %>% 
  arrange(y_val)
ggplot(temp, aes(y_val, auc_mean, colour = q)) + 
  geom_point(position = position_dodge(width = 0.1)) +
  coord_flip() +
  geom_segment(aes(y = auc_lwr, yend = auc_upr, x = y_val, xend = y_val)) +
  scale_x_continuous(breaks = labs$y_val, labels = labs$y) +
  xlab("") + ylab("AUC") +
  theme_sleek()
```

# Q3 How are the "best" models affected by important characteristics of stand structure, that are NOT easily attainable?

Just for `Firemort.BA.p` this time. Will come back to this and repeat over all responses.

Because the quadratic mean diameter predictors are not available for the 0s (not burned at all) we will have to use a "OIB" one-inflated-beta GLMM. Here I am including all of the interactions in a single model. Alternatively, we could do each individually. Note that each predictor has been scaled by dividing by 2 SDs and subtracting its mean. This puts them on approximately the same scale. 

```{r q3-fit, cache=TRUE}
sm <- stan_model("zoib1re.stan")
sm_oib <- stan_model("oib1re.stan")

x_vars <- c(
  "RdNBR_BL",
  "RdNBR_BL",
  "RdNBR_BL",
  "RdNBR_BL",
  "RdNBR_BL"
)
y_vars <- c(
  "BOLESCORCH",
  "CHARCOV",
  "CHARHT_percMax",
  "Firemort.BA.p",
  "Firemort.trees.p")
vars <- data.frame(x = x_vars, y = y_vars, stringsAsFactors = FALSE)

x_vars <- tolower(c("xscaled"))
extra_x_vars <- c("qmd_laf", "qmd_all", "ba_ha", "stems_ha", "redgraygreenstage_ba_p")
x_vars <- paste(x_vars, extra_x_vars, sep = " * ")

out_q3 <- plyr::mlply(.data = vars, function(x, y) { # or map2() without parallel
  d <- get_dat(!!quo_name(y), !!quo_name(x),
    file = file,
    max_predictor = 2500)
  dd <- filter(d, !is.na(qmd_laf), !is.na(qmd_all))
  m <- fit_model_oib(dd, sm_oib, predictors = x_vars, iter = 4000, chains = 1)
  list(m = m, d = dd, x = x, y = y)
}, .parallel = TRUE)
```

Let's plot out the main effect coefficients and the interaction coefficients. This takes a little bit of data manipulation first. The dots are medians, the thick lines are 50% credible intervals, and the thin lines are 95% credible intervals.

```{r plot-interactions, cache=TRUE, fig.height=9, fig.width=10}
p_q3 <- lapply(out_q3, function(x) plot_zoib_coefs(x, oib = TRUE))
library(gridExtra)
n <- length(p_q3)
nCol <- floor(sqrt(n))
do.call("grid.arrange", c(p_q3, ncol = nCol))
```

Examples:

```{r}
cols <- viridis::plasma(3, end = 0.85) %>% rev()
quants <- c(0.05, 0.5, 0.95)

plot_interaction(out_q3[[1]], int_var = "qmd_laf", int_lab = "\nqmd_laf", 
  xlab = vars$x[[1]], col = cols, quant = quants, title = vars$y[[1]], type = "oib")

plot_interaction(out_q3[[2]], int_var = "redgraygreenstage_ba_p", 
  int_lab = "\nRGGStg BA", xlab = vars$x[[2]], col = cols, quant = quants, title = vars$y[[2]], type = "oib")

plot_interaction(out_q3[[3]], int_var = "ba_ha", int_lab = "\nBA", 
  xlab = vars$x[[3]], col = cols, quant = quants, title = vars$y[[3]], type = "oib")

plot_interaction(out_q3[[4]], int_var = "ba_ha", int_lab = "\nBA", 
  xlab = vars$x[[4]], col = cols, quant = quants, title = vars$y[[4]], type = "oib")

plot_interaction(out_q3[[5]], int_var = "ba_ha", int_lab = "\nBA", 
  xlab = vars$x[[5]], col = cols, quant = quants, title = vars$y[[5]], type = "oib")
```

All:

```{r}
inter_vars <- c("qmd_laf", "qmd_all", "ba_ha", "stems_ha", "redgraygreenstage_ba_p")
inter_vars_long <- c("QMD\n(live at fire)", "QMD", "Stand\nbasal area", "Stand density", 
  "Pre-fire beetle\noutbreak severity")
vars_i <- seq_along(inter_vars)
response_j <- seq_along(out_q3)
q3_inter_plots <- list()
k <- 0
for (j in response_j) {
  for (i in vars_i) {
    k <- k + 1
    q3_inter_plots[[k]] <- 
      plot_interaction(out_q3[[j]], int_var = inter_vars[i], 
        int_lab = paste0("\n", inter_vars_long[i]), 
      xlab = gsub("_BL", "", "RdNBR_BL"), col = cols, quant = quants, 
        title = var_names$new.names[var_names$y == vars$y[[j]]], 
        type = "oib", return_data = TRUE)
    q3_inter_plots[[k]]$interaction <- inter_vars_long[i]
    q3_inter_plots[[k]]$response <- var_names$new.names[var_names$y == vars$y[[j]]]
  }
}
q3_inter_plots_df <- bind_rows(q3_inter_plots)
q3_inter_plots_df$level <- as.factor(q3_inter_plots_df$level)
g <- ggplot(q3_inter_plots_df, aes(x, est, ymin = lwr, ymax = upr, group = level,
  fill = level)) +
  geom_line(lwd = 1.2, aes(colour = level)) +
  geom_ribbon(alpha = 0.25) +
  facet_grid(interaction~response) +
  ylim(0, 1) +
  ggsidekick::theme_sleek() +
  ylab("Proportion") +
  xlab("RdNBR_BL") +
  labs(colour = "Quantile",
    fill = "Quantile") +
  scale_colour_manual(values = cols, guide = guide_legend(reverse = TRUE)) +
  scale_fill_manual(values = cols, guide = guide_legend(reverse = TRUE)) +
  scale_y_continuous(breaks = c(seq(0, 0.8, 0.2))) +
  coord_cartesian(expand = FALSE) +
  theme(legend.justification = c(1, 0), legend.position = c(0.2, 0.8), 
    panel.spacing = unit(-0.05, "lines")) +
  xlab("RdNBR")

pdf("figs/q3-interaction-ribbons.pdf", width = 8, height = 5.5)
print(g)
dev.off()
```
